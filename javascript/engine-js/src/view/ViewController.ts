import {Card} from "../tokenScript/Card";
import {IViewBinding} from "./IViewBinding";
import {ITransactionListener, ITransactionStatus, TokenScript} from "../TokenScript";
import {RpcRequest, RpcResponse} from "../wallet/IWalletAdapter";
import {LocalStorageProxy, LocalStorageRequest} from "./data/LocalStorageProxy";
import {TokenViewData} from "./TokenViewData";

export enum ViewEvent {
	TOKENS_UPDATED = "tokensUpdated",
	GET_USER_INPUT = "getUserInput",
	EXECUTE_CALLBACK = "executeCallback",
	ON_CONFIRM = "onConfirm",
	TRANSACTION_EVENT = "transactionEvent"
}

export enum RequestFromView {
	SIGN_PERSONAL_MESSAGE = "signPersonalMessage",
	PUT_USER_INPUT = "putUserInput",
	CLOSE = "close",
	ETH_RPC = "ethRpc",
	LOCAL_STORAGE = "localStorage"
}

/**
 * The ViewController acts as an intermediary between the user-agent supplied viewAdapter (IViewBinding) & the engine
 * This allows us to have more complex logic in the ViewController in order to keep IViewBinding simple & low-level
 *
 * The view binding also calls method on the ViewController for various functions, such as setting user-input attributes.
 */
export class ViewController {

	private currentCard?: Card;
	private _tokenViewData?: TokenViewData;
	private userEntryValues: {[scopeId: string]: {[key: string]: any}} = {};
	private localStorageProxy: LocalStorageProxy;

	constructor(public readonly tokenScript: TokenScript, private viewAdapter: IViewBinding) {
		this.localStorageProxy = new LocalStorageProxy(this.tokenScript);
	}

	/**
	 * Show a card in the user interface
	 * @param card
	 * @param transactionListener
	 */
	async showOrExecuteCard(card: Card, transactionListener?: ITransactionListener){

		if (!card.view){
			// Transaction-only card
			return card.executeTransaction(transactionListener);
		}

		//this.userEntryValues = {};
		this.currentCard = card;
		this._tokenViewData = new TokenViewData(this.tokenScript, this.currentCard);

		this.viewAdapter.viewLoading();

		await this.viewAdapter.showTokenView(this.currentCard);
	}

	public get tokenViewData () {
		return this._tokenViewData;
	}

	async executeTransaction(card: Card, transactionListener?: ITransactionListener){

		const transaction = this.currentCard.getTransaction();

		if (transaction){

			console.log(transaction.getTransactionInfo());

			try {
				await this.currentCard.executeTransaction((data: ITransactionStatus) => {
					this.viewAdapter.dispatchViewEvent(ViewEvent.TRANSACTION_EVENT, data, "0");
					if (transactionListener)
						transactionListener(data);
				});
			} catch (e){
				this.viewAdapter.dispatchViewEvent(ViewEvent.TRANSACTION_EVENT, {status: "error", message: e.message}, "0");
				throw e;
			}

		} else {
			this.dispatchViewEvent(ViewEvent.ON_CONFIRM, {}, "0");
		}
	}

	/**
	 * Unload the card from the UI
	 */
	async unloadTokenCard(){
		this.currentCard = null;
		await this.viewAdapter.unloadTokenView();
	}

	/**
	 * The current card loaded in the UI
	 */
	getCurrentCard(){
		return this.currentCard;
	}

	/**
	 * Gets a specific user-entry value that has been set by the token card Javascript
	 * @param key
	 * @param scopeId
	 */
	getUserEntryValue(key: string, scopeId: string){
		if (!this.userEntryValues[scopeId]?.[key])
			return undefined;

		return this.userEntryValues[scopeId][key];
	}

	/**
	 * Sets user entry values (usually called from the viewAdapter)
	 * @param userEntryValues
	 */
	async setUserEntryValues(userEntryValues: {[key: string]: any}){

		const changedKeys = [];

		let shouldRefresh = false;

		const scopeId = this.tokenScript.getCurrentTokenContext().selectedTokenId ?? "-1";

		if (!this.userEntryValues[scopeId])
			this.userEntryValues[scopeId] = {};

		for (let key in userEntryValues){

			if (this.userEntryValues[scopeId][key] &&
				this.userEntryValues[scopeId][key] === userEntryValues[key]){
				continue;
			}

			if (!this.userEntryValues[scopeId][key] && userEntryValues[key] === "")
				continue;

			const attr = this.findAttribute(key);

			// Attributes that are explicitly defined as user entry SHOULD NEVER refresh the view! This can cause loops and all kinds of crazy behavior.
			// However, in the example of ENS, some views require attributes that depend on a value generated by the view in order to refresh the view.
			// By this example these attributes are not specified at all in the XML, defined only by the Javascript, so we can use this check to determine if view data needs to be refreshed.
			if (!attr && !shouldRefresh)
				shouldRefresh = true;

			console.log("User input '" + key + "' changed (" + this.userEntryValues[scopeId][key] + " -> " + userEntryValues[key] + ")");
			// Invalidate attributes that depend on changed user entry value
			changedKeys.push(key);
			this.userEntryValues[scopeId][key] = userEntryValues[key];
		}

		if (changedKeys.length > 0) {

			this.tokenScript.getAttributes().invalidate(changedKeys);
			if (this.currentCard)
				this.currentCard.getAttributes().invalidate(changedKeys);

			if (shouldRefresh) this.updateCardData();
		}
	}

	/**
	 * Find a specific attribute by name, either from the global scope or the scope of the currently loaded card
	 * @param name
	 * @private
	 */
	private findAttribute(name: string){

		if (this.tokenScript.getAttributes().hasAttribute(name))
			return this.tokenScript.getAttributes().getAttribute(name);

		if (this.currentCard && this.currentCard.getAttributes().hasAttribute(name))
			return this.currentCard.getAttributes().getAttribute(name);

		return null;
	}

	async handleMessageFromView(method: RequestFromView, params: any){

		console.log("Request from view: ", method, params);

		switch (method) {

			case RequestFromView.ETH_RPC:
				this.rpcProxy(params);
				break;

			case RequestFromView.SIGN_PERSONAL_MESSAGE:
				this.signPersonalMessage(params.id, params.data);
				break;

			case RequestFromView.PUT_USER_INPUT:
				await this.setUserEntryValues(params);
				break;

			case RequestFromView.CLOSE:
				this.unloadTokenCard()
				break;

			case RequestFromView.LOCAL_STORAGE:
				this.localStorageProxy.handleLocalStorageRequest(params as LocalStorageRequest);
				break;

			default:
				throw new Error("TokenScript view API method: " + method + " is not implemented.");
		}
	}

	/**
	 * Signs a personal message with the provided data and returns the result to the token view.
	 * @param id
	 * @param data
	 */
	private async signPersonalMessage(id, data){

		try {
			let res = await this.tokenScript.getEngine().signPersonalMessage(data);

			this.dispatchViewEvent(ViewEvent.EXECUTE_CALLBACK, {error: null, result: res}, id);

		} catch (e){
			console.error(e);
			this.dispatchViewEvent(ViewEvent.EXECUTE_CALLBACK, {error: e.message, result: null}, id);
		}
	}

	/**
	 *
	 * @param request
	 */
	private async rpcProxy(request: RpcRequest){

		try {
			let res = await (await this.tokenScript.getEngine().getWalletAdapter()).rpcProxy(request);

			this.dispatchRpcResult({jsonrpc: "2.0", id: request.id, result: res});

		} catch (e){
			console.error(e);
			this.dispatchRpcResult({jsonrpc: "2.0", id: request.id, error: e.valueOf()});
		}
	}

	/**
	 * Dispatch an event to the token card Javascript
	 * @param event
	 * @param data
	 * @param id
	 */
	dispatchViewEvent(event: ViewEvent, data: any, id: string){
		return this.viewAdapter.dispatchViewEvent(event, data, id);
	}

	/**
	 * Dispatch an event to the token card Javascript
	 * @param response RpcResponse
	 */
	dispatchRpcResult(response: RpcResponse){
		return this.viewAdapter.dispatchRpcResult(response);
	}

	/**
	 * Reload card attributes & dispatch the TOKENS_UPDATED event to the card Javascript
	 */
	async updateCardData(){
		this.viewAdapter.viewLoading();

		this.viewAdapter.dispatchViewEvent(ViewEvent.TOKENS_UPDATED, await this.tokenViewData.getCurrentTokenData(true), this.tokenViewData.getViewDataId());
	}
}
